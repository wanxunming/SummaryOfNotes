- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。



「 **大O符号表示法** 」，即 T(n) = O(f(n))

```js
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) 

在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度**。

我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)

为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。所以上面的例子中，如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。



常见的时间复杂度量级有：

- 常数阶O(1)

```js
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

- 对数阶O(logN)

```js
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

- 线性阶O(n)

```js
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

- 线性对数阶O(nlogN)

```js
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

- 平方阶O(n²)

```js
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}

//这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²) 如果将其中一层循环的n改成m，即：

for(x=1; i<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

- 立方阶O(n³)
- K次方阶O(n^k)
- 指数阶(2^n)

空间复杂度比较常用的有：O(1)、O(n)、O(n²)，



例题：

假设我们需要爬一个楼梯，这个楼梯一共有 N 阶，可以一步跨越 1 个或者 2 个台阶，那么爬完楼梯一共有多少种方式？

解题思路：我们从1阶楼梯开始找共有几种方式，我们发现，1阶楼梯有一种上楼方式，2阶楼梯有两种上楼方式，3阶楼梯有3种上楼方式，4阶楼梯有5中上楼方式，我们这里可以发现每x阶层的上楼方式等于x-1层和x-2层上楼方式的和，这个时候我们就可以根据这种规律来写代码了。

```java
class Solution {
    public int climbStairs(int n) {
        int p = 0, q = 0, r = 1;
        for(int i = 1; i <= n; i++){
            p = q;
            q = r;
            r = p + q;
        }
        return r;
    }
}
//复杂度分析
//时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。
//空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。
```

